# 1. 객체지향이란?

## `Q1. 객체 지향은 클래스이다?`

 객체지향이 무엇인가 질문을 던진다면, 객체지향은 프로그래밍의 패러다임을 구현하기 위한 방법 중 하나라는 점을 명심해야 한다. 객체 지향은 프로그래밍을 하기 위한 방법론이자 패러다임이기 때문이다. 클래스는 이러한 맥락 속에서 객체지향이라는 패러다임을 실현하기 위한 방법의 하나이다. 

 웹에서 쓰이는 자바스크립트는 프로토 타입 기반이다. 자바스크립트에서는 객체들간의 위임으로 객체 지향이 실현된다. 또한 자바스크립트의 객체는 그럼 무엇이냐 라고 물을 때 자바 스크립트는 딕셔너리를 기반으로 객체를 구현한다. 이처럼 `객체 지향`은 언어를 불문하고 어떻게 프로그래밍을 하느냐에 대한 패러다임이자 방법론이라고 할 수 있겠다.

 흔히 객체 지향을 설명할 때, 현실에 실존하는 것을 컴퓨터로 표현하는 데에는 한계가 있으므로, 객체가 필요했다 라는 설명이 많을 것이다. 이 설명은 분명 객체 지향을 처음 접하는 사람들에게는 아주 좋은 예시이며 이해를 돕는 문구가 된다. 그러나 조금 엄밀히 이야기하면 오히려 프로그래밍 언어의 객체는 현실세계의 존재와 상이하다고 봐야할 것이다. 가령 현실세계의 사람은 날거나 물에서 호흡하거나 할 수 없는 반면, 프로그래밍에서의 사람이란 객체는 날 수도 있고, 물에서 호흡도 하고, 순간이동도 할 수 있다. 오히려 혹자는 이러한 설명이 비약적이라고 느낄 수 있지만 `객체 지향` 이라는 것에 대해 오래 고민할 사람이라면 이 점을 짚어보는 것이 좋을 것 같다.

 객체 지향에서 객체간의 상호 작용은 `요청과 응답` 크게 두 가지 행위로 정의할 수 있다. 다른 객체로부터 정보를 받는 다던가, 다른 객체에게 응답을 준다던가 하는 아주 간단한 작업에서부터 시작해 객체 지향은 현실 세계보다 더 다양하고, 복잡한 기능을 구현하고 실현시킬 수 있게 된다.

 객체 지향에서 클래스 변수, 인스턴스 변수가 왜 필요하고 왜 구분짓냐고 한다면, 그것은 객체 지향에서 객체는 서로 상호작용을 하기에 어떤 객체의 상태나 정보를 저장할 곳이 없다면 `절차 지향`으로써 처리할 수 밖에 없고, 아주 간단한 기능을 수정하는 작업이라 하더라도, 그 프로그램이 복잡하다면 전체의 코드를 손봐야 하고, 그 작업의 규모는 커질 것이 자명하다. 따라서, 객체 내부에 어떤 변수를 두는 행위, 함수(=메서드)를 구현하는 행위는 객체 지향에서 객체의 상호 작용이 간단한 `요청과 응답`에서 시작하나, 거미줄이 얽힌 것처럼 규모가 커질수록 복잡해지기에 이를 교통 정리하고, 사람이 다루기 쉽도록 하는 것이다.

-------------------------

# 2. 객체 지향의 네가지 핵심 개념

## 1. 추상화(Abstraction) - 핵심적인 코드만 보여주기
- 불필요한 부분을 숨긴다.
- 인터페이스와 구현을 분리한다 

## 2. 캡슐화(encapsulation) - 데이터 보호
- 데이터 캡슐화 : 필드와 메서드를 하나로 묶는 것
- 은닉화 : 객체의 세부 내용이 외부에 드러나지 않아 외부에서 데이터를 직접 접근하는 것을 방지한다.

## 3. 상속(inherutance) - 코드 재사용
- 자식클래스가 부모클래스의 특징과 기능을 물려받는 것
- 클래스를 상속 받아 수정하여 사용하기 때문에 중복 코드를 줄일 수 있다.
- 부모클래스의 수정으로 모든 자식클래스들도 수정되는 효과
- 클래스에 메소드 추가가 어려운 경우 사용
- 자신이 아닌 남이 만든 클래스를 가져오는 경우 (수정 불가)
- 클래스가 다양한 곳에서 상속 받아 쓰이는 경우 (메서드를 추가하면 다른 곳에서 불필요한 기능이 포함될 수 있음)

## 4. 다형성(polymorphism) - 객체 변경 용이
> 어떤 변수, 메소드가 상황에 따라 다른 결과를 내는 것

`다형성을 가능하게 하는 두 가지`

- 오버라이딩(overriding) : 부모클래스 메서드를 자식클래스에서 재정의하는 것

- 오버로딩(overloading) : 한 클래스에서 메소드 이름은 같지만 파라미터 개수나 자료형을 다르게 하여 서로 다르게 동작하게 하는 것



[출처 : OOP의 네가지 특징(추상화/캡슐화/상속/다형성)](https://velog.io/@0sunset0/OOP%EC%9D%98-%EB%84%A4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95%EC%B6%94%EC%83%81%ED%99%94%EC%BA%A1%EC%8A%90%ED%99%94%EC%83%81%EC%86%8D%EB%8B%A4%ED%98%95%EC%84%B1)

----------------------------------------

# 3. 객체지향 개발의 5가지 원리 : SOLID

## 1. 단일 책임의 원칙 (SRP, Single Responsibility Principle)

- 단일 책임 원칙(SRP)은 하나의 모듈은 하나의 책임을 가져야 한다는 것으로, 모듈이 변경되는 이유가 한가지여야 함을 의미.

- 어떤 모듈이여러 대상 또는 액테들에 대한 책임을 가져서는 안되고, 오직 하나의 액테어 대해서만 책임을 져야 한다.

- 로그인 시스템의 경우 로그인 기능, 패스워드의 암호화 기능이 있다고 했을 때, 패스워드의 암호화 기능 / 로그인 기능으로 세분화하여 각각의 기능을 구현 및 설계 해야함.

- 이 원칙을 지키면, 변경이 필요할 때 수정할 대상이 명확해지고, 시스템이 커질수록 장점이 극대화 됨.

## 2. 개방 폐쇄 원칙 (OCP, Open-Closed Principle)
개방 폐쇄 원칙(Open-Closed Principle)은 확장에 대해 열려 있고, 수정에 대해서는 닫혀 있어야 한다는 원칙으로 각각이 갖는 의미는 다음과 같다.

- 확장에 대해 열려있다 : 요구 사항이 변경될 때 새로운 동작을 추가하여 애플래케이션의 기능을 확장할 수 있다.

- 수정에 대해 닫혀 있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.

- 비밀번호 암호화를 강화해야한다는 요구가 있을 때 비밀번호 암호화를 강화한 기법을 적용한다고 가정하자. 만약 이때에 비밀번호 암호화 정책을 적용하려 봤더니 새로운 암호화 정책과 무관한 것을 수정해야하는 문제가 발생할 수 있다. 이때, 기존의 코드를 수정해야 하지 않는다는 개방 폐쇄 원칙에 위배되고, 이는 곧 다음에 또 정책이 변화할 때 OCP를 위배하는 결과가 연속된다.

- 이러한 문제점을 해결하기 위해서는 `추상화`에 의존해야 한다. 핵심적인 부분만 남기고 복잡한 것은 간단히 하는 것으로 , 변하지 않는 부분은 고정하고 변화하는 부분은 추상화함으로써 생략된 부분을 수정해 개방-폐쇄 원칙을 지킬 수 있다.

-  이 원칙이 본질적으로 이야기하고자 하는 것은 `추상화` 이다.


## 3. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

- 객체가 충분히 높은 응집도의 단위로 설계 되었더라도 목적과 관심이 각기 다른 클라이언트가 있다면, 인터페이스를 통해 적절하게 분리해줄 필요가 있는데, 이를 인터페이스의 분리 원칙이라고 부른다.

- 요약하자면, 클라이언트의 목적과 용도오 적합한 인터페이스 만을 제공하여 인터페이스 분리 원칙을 준수해 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스만을 접근하여 불필요한 간섭을 최소화할 수 있는 것이다.


## 4. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

- 1988년 바바라 리스코프가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것이다.

- 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도, 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 이용할 수 있어야 한다는 것이다.

## 5. 의존 역전 원칙 (DIP, Dependency Inversion Principle)
 
- 의존 역전 원칙이란 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고 수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것이다.

- 객체 지향 프로그래밍에서는 객체들 사이에 메세지를 주고 받기 위해 의존성이 생기는데 의존성 역전의 원칙은 올바른 의존 관계를 위한 원칙에 해당되며 각각의 의미는 다음과 같다.

고수준 모듈 = 변경이 없는 추상화된 클래스(또는 인터페이스)
저수준 모듈 = 변하기 쉬운 구체적인 클래스

- 의존 역전 원칙이란 결국 추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙을 의미




[[SOLID 원칙] : https://mangkyu.tistory.com/194 [MangKyu's Diary:티스토리]](https://mangkyu.tistory.com/194)

