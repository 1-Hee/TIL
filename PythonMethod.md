
# Methods

## 1. String.Method

| 문법 | 설명 |
|----|----|
| .find(x) | x의 첫번째 위치를 반환. 없으면, -1 반환 |
| .index(x) | x의 첫번째 위치를 반환. 없으면, 오류 발생 |
| .isalpha() | 알파벳 문자여부 (*단순 알파벳이 아닌 유니코드 상 문자 한국어 포함) |
| .isupper() | 대문자 여부 |
| .islower() | 소문자 여부 |
| .istitle() | 타이틀 형식 여부 |
| .isdecimal() | 진짜 숫자인지, 특수문자 숫자형 x|
| .isdigit() | decimal()보다 조금 더 까다롭게 숫자 검사|
| .isnumeric | 가장 널널하게 검사, 숫자 비슷하면 대부분 pass |
| .place(old, new[, count]) | 바꿀 대상 글자를 새로운 글자로 바꿔서 변환|
| .strip([chars]) | 공백이나 특정 문자를 제거 |
| .split(sep = None, maxsplit = -1) | 공백이나 특정 문자를 기준으로 분리 |
| ''.join([iterable]) | 구분자로 iterable을 합침 |
| .capitalize() | 가장 첫 번째 글자를 대문자로 변경 |
| .title() | 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환 |
| .upper() | 모두 대문자로 변경 |
| .lower() | 모두 소문자로 변경 |
| .swapcase() | 대<->소 문자 서로 변경|


## 2. List Method

| 문법 | 설명 |
| ---- | ---- |
| .append(x) | 리스트의 마지막에 x를 추가 |
| .insert(i, x) | 리스트 인덱스 i에 항목 x를 삽입 |
| .remove(x) | 리스트 가장 왼쪽에 있는 항목 x를 제거, 항목이 존재하지 않으면 value Error |
| .pop() | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거 |
| .pop(i) | i번째 인덱스에 있는 항목을 반환 후 제거 |
| .extend() | 순회형 m의 모든 항목들의 리스트 끝에 추가 (+= 과 같은 기능) |
| .index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환 |
| .reverse() | 리스트를 거꾸로 정렬 |
| .sort() | 리스트를 정렬 (매개변수 이용 가능) |
| .count(x) | 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환 |
| .clear() | 모든 항목을 삭제함 |


## 3. Tuple Method

| 문법 | 설명 |
| ---- | ---- |
| | |

` 나중에 수정 해야함 `


## 4. Set Method
| 문법 | 설명 |
| .copy() | 셋의 얕은 복사본을 반환 |
| .add(x) | 항목 x가 set에 없다면 추가 |
| .pop() | 셋에서 랜덤하게 항목을 반환하고, 해당 항목을 제거 |
| .remove() | 항목 x를 셋에서 삭제, 항목이 존재하지 않으면 KeyError |
| .discard(x) | 항목 x를 셋에서 삭제 없으면 nothing and no Error |
| .update(t) | 셋(t)에 있는 모든 항목 중 셋에 없는 항목을 추가, (셋합집합) |
| .clear() | 모든 항목을 제거 |
| .isdisjoint(t) | 셋이 셋(t)와 하나라도 같은 항목이 없으면 True 반환 |
| .issubset(t) | 셋이 셋(t)의 하위 셋인 경우 True (완전 포함 관계인지)|
| .issuperset(t) | subset의 역으로 셋(t)가 셋의 하위셋인지 = 셋이 셋(t) 의 상위셋인지 True or False |


## 5. Dictionary Method
| 문법 | 설명 |
| ---- | ---- |
| .clear() | 모든 항목을 제거 |
| .copy() | 딕셔너리의 얕은 복사본을 반환 |
| .keys() | 딕셔너리의 모든 키를 담은 뷰를 반환 |
| .values() | 딕셔너리의 모든 값을 담은 뷰를 반환 |
| .items() | 딕셔너리의 모든 키-값의 쌍을 담은 뷰를 반환 |
| .get(k) | 키 k의 값을 반환하는데, 키 k가 딕셔너리에 없을 경우 None을 반환 |
| .get(k, y) | 키 k의 값을 반환하는데, 키 k가 딕셔너리에 없을 경우 v를 반환 |
| .pop(k) | 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리에서 삭제하는데, 키 k가 딕셔너리에 없을 경우 KeyError를 발생 |
| .pop(k, v) | 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리에서 삭제하는데, 키 k가 없으면 v를 반환 |
| .update([other]) | 딕셔너리의 값을 매핑하여 업데이트 |


## 6. 얕은 복사와 깊은 복사 (Shallow Copy & Deep Copy)

### 복사 방법 
- 할당 (Assignment)
- 얕은 복수 (Shallow Copy)
- 깊은 복사 (Deep Copy)

 변수를 한번 선언하고 그 안의 값일 변경할 때 = 연산자를 많이 사용합니다. 그러나 그 변수가 immutable인 경우에는 원래 주소에 새로운 값이 쓰여지는 것이 아니라 아예 새로운 주소값을 할당받아 버립니다. 반면 list와 같은 mutable 인 경우에는 id 값이 고정되어 있음을 확인할 수 있습니다. 그러나 mutable에서는 copy 깊이에 대한 문제가 발생할 수 있습니다.

``` python
a = [1,2,3,4]
b = a
b[0] = 3
```
 위와 같이 코드를 짰다고 가정해보겠습니다. 그러면 a[0] 은 얼마일까요? 정답은 3입니다. 분명 새로운 변수에 담았는데, 기존의 변수 a의 값도 변경되었습니다. 이유는 지금과 같은 상황에서 파이썬은 b에 새로운 공간을 확보해주는 것이 아니라, a의 주소값을 넣어주기 때문입니다. 따라서, b를 변경하면 결과적으로 a를 바꾼 셈이 됩니다.

### Deepcopy

 Shallow Copy(얕은 복사) 문제를 해결하는 방법은 여러 가지가 있겠지만, 그중에서도 쉽게 라이브러리를 통해 해결하는 방법이 있습니다.

``` python
import copy

a = [1,2,3,4]
b = copy.deepcopy(a)
b[0] = 3
# a = [1,2,3,4]
# b = [3,2,3,4]

```
